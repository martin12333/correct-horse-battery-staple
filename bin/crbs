#!/usr/bin/env ruby

require 'correct_horse_battery_staple'
require 'correct_horse_battery_staple/assembler'
require 'commander/import'

program :version, "0.1.0"
program :description, "Correct Horse Battery Staple - XKCD-style Passphrases"

global_option '-D', '--debug', 'Display full protocol trace'
global_option '-V', '--verbose', 'Shows request and response'

command :generate do |c|
  c.syntax = 'generate [<number of words>]'
  c.summary = 'Generate a passphrase with a given number of words'
  #c.description = ''
  #c.example 'description', 'command example'
  c.option '-f FORMAT', '--format FORMAT', 'Set the corpus format'
  c.option '-c CORPUSFILE', '--corpus CORPUSFILE', "File to use as the source corpus"
  c.option '-n COUNT', '--repeat COUNT', Integer, 'How many passwords to generate'

  # filters
  c.option '-W MIN..MAX', '--wordsize MIN..MAX',
           'Set the allowed word size in number of characters'
  c.option '-P MIN..MAX', '--percentile MIN..MAX',
           'Set the percentile range of the word frequency'

  c.action do |args, options|
    options.default :wordsize => "3..7", :repeat => 1, :corpus => "wiktionary",
                    :format => "json", :percentile => "30..80"

    number_of_words = (args[0] || 4).to_i
    count = options.repeat.to_i

    corpus = CorrectHorseBatteryStaple.load_corpus(options.corpus, options.format)
    puts "loaded corpus!" if options.debug
    unfiltered_size = corpus.length

    f_wordsize = CorrectHorseBatteryStaple::RangeParser.new.parse options.wordsize

    unless f_wordsize.begin <= 1 && f_wordsize.end >= 30
      corpus.filter {|entry| f_wordsize.include? entry.word.length }
    end

    f_percentile = CorrectHorseBatteryStaple::RangeParser.new.parse options.percentile
    unless f_percentile.include? 0..100
      corpus.filter {|entry| f_percentile.include? entry.percentile }
    end

    corpus = corpus.result
    entropy = number_of_words * corpus.entropy_per_word.floor
    if options.verbose
      guesses_per_sec = 1000.0
      search_space = 2**entropy
      years = search_space / guesses_per_sec / (365*24*3600)
      puts "Corpus size: #{corpus.length} candidate words of #{unfiltered_size} total"
      puts "Entropy: #{entropy} bits (2^#{entropy} = #{search_space})"
      puts "Years to guess at #{guesses_per_sec.to_i} guesses/sec: #{years.round}"
    end

    generator = CorrectHorseBatteryStaple::Generator.new(corpus)

    count.times do
      puts generator.make(number_of_words)
    end
  end
end

command :mkcorpus do |c|
  c.syntax = 'mkcorpus file [file, file, ...]'
  c.summary = 'Generate a JSON or CSV corpus from an input file'
  #c.description = ''
  #c.example 'description', 'command example'
  c.option '-i FORMAT', '--iformat FORMAT', 'Set the input format - "wiktionary" or "wordfrequency"'
  c.option '-o FORMAT', '--oformat FORMAT', 'Set the output format - "marshal", "json", or "csv"'
  c.option '-R', '--randomize', 'Randomize word order'
  c.option '-l COUNT', '--limit COUNT', Integer, 'Set the maximum words processed'
  c.action do |args, options|
    options.default :iformat => "wiktionary", :oformat => "json", :limit => -1

    assembler = CorrectHorseBatteryStaple::Assembler.new(
      CorrectHorseBatteryStaple::Parser::Regex.new(options.iformat.to_sym))
    assembler.read(args)
    assembler.randomize if options.randomize
    if options.limit > -1
      assembler.limit(options.limit)
    end
    assembler.process
    case options.oformat.to_sym
      when :json    then assembler.save_as_json(STDOUT)
      when :csv     then assembler.save_as_csv(STDOUT)
      when :marshal then assembler.save_as_marshal(STDOUT)      
      else raise ArgumentError, "Supported output formats are 'json' and 'csv'"
    end
  end
end

